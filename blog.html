<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Javascript Blogs</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi"
      crossorigin="anonymous"
    />
  </head>
  <body>
    <header class="bg-success p-5 mb-4">
      <div class="container">
        <div class="row">
          <div class="col">
            <h2 class="text-center text-white h1">Blog-Page</h2>
          </div>
        </div>
      </div>
    </header>
    <main>
      <div class="container">
        <div class="row">
          <div class="col">
            <h2 class="fst-italic">
              1.Difference Between Local Storage And Session Storage
            </h2>
            <p>
              The HTTP protocol is one of the most important protocols for
              smooth communication between the server and the client. The main
              disadvantage of the HTTP protocol it is a stateless protocol that
              means it does not track any kind of information of response and
              request by the server and the client, So in order to resolve this
              problem, there are three ways to track useful information In this
              article we are going to see the difference between Local Storage,
              Session Storage, and Cookies and why it’s important for a web
              developer to know these terms.
            </p>
            <p>
              <span class="fw-bold h5 fst-italic text-warning"
                >LocalStroage :</span
              >
              This read-only interface property provides access to the
              Document’s local storage object, the stored data is stored across
              browser sessions. Similar to sessionStorage, except that
              sessionStorage data gets cleared when the page session ends – that
              is when the page is closed. It is cleared when the last “private”
              tab of a browser is closed (localStorage data for a document
              loaded in a private browsing or incognito session). DOMStrings are
              storage formats that use UTF-16 to encode data, which uses two
              bytes per character. Strings are automatically generated from
              integer keys just as they are for objects. The data stored in
              LocalStorage is specific to a protocol in the document. If the
              site is loaded over HTTP (e.g., http://example.com), localStorage
              returns a different object than if it is loaded over HTTPS (e.g.,
              https://abc.com). If a document is loaded from a file: URL (that
              is, directly from the user’s local file system instead of being
              loaded from the server) the requirements for behavior are
              undefined and may vary among different browsers. Each file appears
              to be returned a different object by localStorage in all current
              browsers: URL. Essentially, it seems to be a case of each URL:
              file having its own unique local storage area.
            </p>
            <p>
              <span class="fw-bold h5 fst-italic text-warning"
                >SessionStroage :</span
              >
              Session Storage objects can be accessed using the sessionStorage
              read-only property. The difference between sessionStorage and
              localStorage is that localStorage data does not expire, whereas
              sessionStorage data is cleared when the page session ends. A
              unique page session gets created once a document is loaded in a
              browser tab. Page sessions are valid for only one tab at a time.
              Pages are only saved for the amount of time that the tab or the
              browser is open; they do not persist after the page reloads and
              restores. A new session is created each time a tab or window is
              opened; this is different from session cookies. Each tab/window
              that is opened with the same URL creates its own
              sessionStorage.When you duplicate a tab, the sessionStorage from
              the original tab is copied to the duplicated tab. Closing a
              window/tab ends the session and clears sessionStorage objects. A
              page’s protocol determines what data is stored in sessionStorage.
              Particularly, data stored by scripts accessed through HTTP (for
              example, http://abc.com) is stored in a separate object from the
              same site accessed through HTTPS (for instance, https://abc.com).
              A DOMString number is two bytes per character in UTF-16 DOMString
              format. Strings are automatically generated from integer keys just
              as they are for objects.
            </p>
          </div>
        </div>
        <div class="row">
          <div class="col">
            <h2 class="fst-italic">2.JavaScript Variable Scope</h2>
            <p>
              In programming, the scope of a variable determines its lifetime.
              The scope describes if a variable, a function or an object is
              accessible or inaccessible by different parts of the program
              during runtime. In this article, we will see examples to cover
              briefly the global, local and block scopes in JavaScript.
            </p>
            <p>
              <span class="fw-bold h5 fst-italic text-warning"
                >The Global scope :</span
              >
              A variable exists inside or outside a block. If a variable is
              declared outside all functions or curly braces ({}), it exists in
              the global scope. The global variables can be accessed by any line
              of code in the program, including inside blocks.
            </p>
            <p>
              <span class="fw-bold h5 fst-italic text-warning"
                >The Local scope :</span
              >
              In contrast to global variables, locally scoped ones are only
              visible within the function they are declared. Each function
              written in JavaScript creates a new local scope and every variable
              declared in this scope is a local variable. That means that
              variables with the same name can be used in different functions.
              However, any effort to reference a local variable outside its
              scope will result in a Reference Error:
            </p>
            <p>
              <span class="fw-bold h5 fst-italic text-warning"
                >The Block scope:</span
              >
              So far, we’ve seen variables defined with the var keyword. Var can
              declare a variable either in the global or local scope. The
              variables that are declared within the block scope are comparable
              to local ones. They are available within the block that they are
              defined. The main difference between the local scope and block
              scope is that the block statements (e.g. if conditions or for
              loops), don't create a new scope. So the var keyword will not have
              an effect, because the variables are still in the same scope.
            </p>
          </div>
        </div>
        <div class="row">
          <div class="col">
            <h2 class="fst-italic">3.event loop in JavaScript?</h2>
            <p class="text">
              <span class="fw-bold h5 fst-italic text-warning"
                >Event Loop:</span
              >
              The event loop is the secret behind JavaScript’s asynchronous
              programming. JS executes all operations on a single thread, but
              using a few smart data structures, it gives us the illusion of
              multi-threading. Let’s take a look at what happens on the
              back-end. The call stack is responsible for keeping track of all
              the operations in line to be executed. Whenever a function is
              finished, it is popped from the stack. svg viewer svg viewer The
              event queue is responsible for sending new functions to the stack
              for processing. It follows the queue data structure to maintain
              the correct sequence in which all operations should be sent for
              execution. Whenever an async function is called, it is sent to a
              browser API. These are APIs built into the browser. Based on the
              command received from the call stack, the API starts its own
              single-threaded operation. An example of this is the setTimeout
              method. When a setTimeout operation is processed in the stack, it
              is sent to the corresponding API which waits till the specified
              time to send this operation back in for processing. Where does it
              send the operation? The event queue. Hence, we have a cyclic
              system for running async operations in JavaScript. The language
              itself is single-threaded, but the browser APIs act as separate
              threads. The event loop facilitates this process; it constantly
              checks whether or not the call stack is empty. If it is empty, new
              functions are added from the event queue. If it is not, then the
              current function call is processed.
            </p>
          </div>
        </div>
        <div class="row">
          <div class="col">
            <h2 class="fst-italic">4.Handle undefined in JavaScript</h2>
            <p>
              The short answer is that JavaScript interpreter returns undefined
              when accessing a variable or object property that is not yet
              initialized
            </p>
            <p class="text">
              <span class="fw-bold h5 fst-italic text-warning">undefined:</span>
              How to get undefined is given below
              <ul>
                <li>Uninitialized variable</li>
                <li>Accessing a non-existing property</li>
                <li>Wrong Function parameters</li>
                <li>Function return value</li>
                <li>void operator</li>
              </ul>
            </p>
          </div>
        </div>
      </div>
    </main>
  </body>
</html>
